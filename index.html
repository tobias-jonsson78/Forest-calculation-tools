<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Röta-analys med zoom/pan (mobil)</title>
<style>
  body { font-family: sans-serif; background: #f8f9fa; margin:0; padding:0; text-align:center; }
  h2 { font-size:1.5em; margin:10px 0; }
  canvas { border:1px solid #aaa; margin-top:10px; touch-action:none; }
  #resultat { margin-top:10px; font-size:1.2em; padding:5px; }
  button { margin:5px; padding:12px 20px; font-size:1em; border-radius:8px; }
  input[type=file] { font-size:1em; margin-top:10px; }
</style>
</head>
<body>

<h2>Rita röta på stockens ände</h2>
<input type="file" id="bildInput" accept="image/*"><br>
<button id="ritBtn" disabled>Aktivera ritläge</button>
<button id="rensaBtn" disabled>Rensa röta</button>
<canvas id="myCanvas"></canvas>
<p id="resultat"></p>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>

<script>
let canvas = document.getElementById('myCanvas');
let ctx = canvas.getContext('2d');
let bildInput = document.getElementById('bildInput');
let rensaBtn = document.getElementById('rensaBtn');
let ritBtn = document.getElementById('ritBtn');

let img = null, imgLoaded=false;
let paths = [], currentPath=[];
let isDrawing=false, ritMode=false;

let stockContour=null;

// Zoom/pan variabler
let offsetX=0, offsetY=0, scale=1;
let lastTouchDist=null;
let lastTouchMid=null;
let isPanning=false;
let lastPan={x:0,y:0};

function onOpenCvReady(){ console.log("OpenCV.js ready"); }

// Ladda bild
bildInput.addEventListener('change', e=>{
  const fil=e.target.files[0]; if(!fil) return;
  const url=URL.createObjectURL(fil);
  img=new Image();
  img.onload=()=>{
    const maxWidth=window.innerWidth*0.95;
    const s = img.width>maxWidth ? maxWidth/img.width : 1;
    canvas.width=img.width*s; canvas.height=img.height*s;
    scale=s; offsetX=0; offsetY=0;

    imgLoaded=true; paths=[]; currentPath=[]; stockContour=null;
    rensaBtn.disabled=false; ritBtn.disabled=false;
    document.getElementById('resultat').innerText='';
    drawCanvas();
    detectStockContour();
  };
  img.src=url;
});

// Rensa
rensaBtn.addEventListener('click', ()=>{
  paths=[]; currentPath=[]; drawCanvas(); document.getElementById('resultat').innerText='';
});

// Aktivera ritläge
ritBtn.addEventListener('click', ()=>{ ritMode=!ritMode; ritBtn.innerText=ritMode?"Ritläge: PÅ":"Ritläge: AV"; });

// Rita canvas
function drawCanvas(){
  if(!imgLoaded) return;
  ctx.setTransform(1,0,0,1,0,0); // reset transform
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.setTransform(scale,0,0,scale,offsetX,offsetY);
  ctx.drawImage(img,0,0,canvas.width/scale,canvas.height/scale);

  // Stock
  if(stockContour){
    ctx.beginPath();
    ctx.arc(stockContour.x,stockContour.y,stockContour.r,0,2*Math.PI);
    ctx.lineWidth=4/scale; ctx.strokeStyle='blue'; ctx.stroke();
  }

  // Röta
  paths.forEach(path=>{
    ctx.beginPath();
    ctx.moveTo(path[0].x,path[0].y);
    for(let p of path) ctx.lineTo(p.x,p.y);
    ctx.closePath();
    ctx.globalAlpha=0.4; ctx.fillStyle='red'; ctx.fill();
    ctx.globalAlpha=1.0; ctx.strokeStyle='red'; ctx.lineWidth=3/scale; ctx.stroke();
  });
}

// Frihandsritning
function startDrawing(x,y){ if(!ritMode) return; isDrawing=true; currentPath=[transformToCanvas(x,y)]; }
function moveDrawing(x,y){ 
  if(!isDrawing) return; 
  currentPath.push(transformToCanvas(x,y));
  drawCanvas();
  ctx.beginPath(); ctx.moveTo(currentPath[0].x,currentPath[0].y);
  for(let p of currentPath) ctx.lineTo(p.x,p.y);
  ctx.strokeStyle='gray'; ctx.lineWidth=3/scale; ctx.stroke();
}
function endDrawing(){
  if(!isDrawing) return; isDrawing=false;
  if(currentPath.length>2) paths.push(currentPath);
  currentPath=[]; drawCanvas();
  if(paths.length>0 && stockContour) calculateRota();
}

// Transformera skärmposition till canvaskoordinater
function transformToCanvas(x,y){ return {x:(x-offsetX)/scale, y:(y-offsetY)/scale}; }

// Mouse & touch events
canvas.addEventListener('mousedown', e=>ritMode?startDrawing(e.offsetX,e.offsetY):(isPanning=true,lastPan={x:e.clientX,y:e.clientY}));
canvas.addEventListener('mousemove', e=>ritMode?moveDrawing(e.offsetX,e.offsetY):(isPanning && panCanvas(e.clientX,e.clientY)));
canvas.addEventListener('mouseup', ()=>{ if(ritMode) endDrawing(); else isPanning=false; });
canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  if(e.touches.length==1 && ritMode) startDrawing(e.touches[0].clientX,e.touches[0].clientY);
  else if(e.touches.length==1){isPanning=true; lastPan={x:e.touches[0].clientX,y:e.touches[0].clientY};}
  else if(e.touches.length==2){ lastTouchDist=getTouchDist(e); lastTouchMid=getTouchMid(e);}
});
canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  if(e.touches.length==1 && ritMode) moveDrawing(e.touches[0].clientX,e.touches[0].clientY);
  else if(e.touches.length==1 && isPanning) panCanvas(e.touches[0].clientX,e.touches[0].clientY);
  else if(e.touches.length==2){ zoomCanvas(e); }
});
canvas.addEventListener('touchend', e=>{
  e.preventDefault();
  if(ritMode) endDrawing();
  if(e.touches.length<2) lastTouchDist=null; if(e.touches.length==0) isPanning=false;
});

// Pan
function panCanvas(x,y){
  offsetX += x-lastPan.x; offsetY += y-lastPan.y; lastPan={x,y}; drawCanvas();
}

// Zoom
function zoomCanvas(e){
  const newDist=getTouchDist(e);
  if(lastTouchDist){
    const scaleFactor=newDist/lastTouchDist;
    scale *= scaleFactor;
    // justera offset för midpunkt
    const mid=getTouchMid(e);
    offsetX = mid.x - (mid.x - offsetX)*scaleFactor;
    offsetY = mid.y - (mid.y - offsetY)*scaleFactor;
    drawCanvas();
  }
  lastTouchDist=newDist; lastTouchMid=getTouchMid(e);
}

function getTouchDist(e){
  const dx=e.touches[0].clientX-e.touches[1].clientX;
  const dy=e.touches[0].clientY-e.touches[1].clientY;
  return Math.hypot(dx,dy);
}
function getTouchMid(e){ return {x:(e.touches[0].clientX+e.touches[1].clientX)/2, y:(e.touches[0].clientY+e.touches[1].clientY)/2}; }

// AI / kantdetektion
function detectStockContour(){
  if(!imgLoaded || !cv) return;
  let src=cv.imread(canvas);
  let gray=new cv.Mat();
  cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
  cv.GaussianBlur(gray,gray,new cv.Size(5,5),0);
  let circles=new cv.Mat();
  cv.HoughCircles(gray,circles,cv.HOUGH_GRADIENT,1,gray.rows/8,100,30,0,0);
  if(circles.cols>0){ const c=circles.data32F; stockContour={x:c[0],y:c[1],r:c[2]}; drawCanvas(); }
  else{ alert("Kunde inte hitta stockens ytterkontur automatiskt."); }
  src.delete(); gray.delete(); circles.delete();
}

// Beräkna procentuell röta
function calculateRota(){
  if(!stockContour) return;
  const tempCanvas=document.createElement('canvas'); tempCanvas.width=canvas.width; tempCanvas.height=canvas.height;
  const tctx=tempCanvas.getContext('2d');

  tctx.beginPath(); tctx.arc(stockContour.x,stockContour.y,stockContour.r,0,2*Math.PI); tctx.fill();
  const stockData=tctx.getImageData(0,0,tempCanvas.width,tempCanvas.height).data;
  let stockPixels=0; for(let i=3;i<stockData.length;i+=4) if(stockData[i]>0) stockPixels++;

  tctx.clearRect(0,0,tempCanvas.width,tempCanvas.height);
  paths.forEach(path=>{ tctx.beginPath(); tctx.moveTo(path[0].x,path[0].y); for(let p of path) tctx.lineTo(p.x,p.y); tctx.closePath(); tctx.fill(); });
  const rotaData=tctx.getImageData(0,0,tempCanvas.width,tempCanvas.height).data;
  let rotaPixels=0; for(let i=3;i<rotaData.length;i+=4) if(rotaData[i]>0) rotaPixels++;

  const procent=(rotaPixels/stockPixels)*100;
  document.getElementById('resultat').innerText=`Röta: ${procent.toFixed(2)}% av stocken`;
}
</script>
</body>
</html>
